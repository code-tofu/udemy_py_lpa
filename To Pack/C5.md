A Sequence is a ordered (indexed) sequence of characters and can be iterable  
- The accurate definition of an iterable is that it's an object that contains  
   - an _iter_ method  
   - or an \_getitem_method  
   - Index must start from zero  
- Not all iterables are sequences - A dictionary is not a sequence although it is iterable.  
- You can slice lists like strings, which are sequences. Slicing a list gives you another list
- Sequence is ordered so you can refer to the items by index positions. Note that Indexes starts from zero

- Lists are square bracketed. Do not confuse referring to indexes vs slicing.
- List elements can be referred to using their indexes starting from zero  
- You can augmented assign lists i.e ["list1","list2"] +=  ["list3"]  
- You can bind multiple names to a list i.e. List1=List2=List3 all refer to the same list
- \[-1] returns last element of a List
- List are mutable compared to strings  

Sequence Methods and functions ref. https://docs.python.org/3/library/stdtype
- Methods have to be called on an object, with parentheses, and arguments are passed into the parentheses if required  
- Methods need to act on a sequence object. arguments are input into the parentheses: Example of sequence methods/functions (Refer to documentation):  
    .min()  
    .max()  
    .len()  
    .any()
    .all()
    .del []  
    .count()  
    .index()  
    .append() - allows for copied, does not check if unique
    .remove()  
    .copy()  
    .count()
    .extend()
    .sort(reverse=True) does not apply to all iterables (mutable only) - the list has been changed directly (in place) it does not create a copy. does not return anything
    .sorted() - returns a (new) sorted list. use argument key=str.casefold() to ignore case sensitivty
- Using “in” to check if something is in list

Mutability
- Strings are immutable (cannot be changed).
- In order to change, python destroys and recreates (in new memory)
- Use id() to find allocated memory? object ID
- All objects in Python has its own unique id. https://www.w3schools.com/python/ref_func_id.asp
- The id is the object's memory address, and will be different for each time you run the program.   
- Reassigning bool values is different in python from other compilers (i.e. it gets recreated)
- Python has to recreate the variable, the value is rebound to the same variable name with a new id  
- Assigning a variable to another variable name binds both names to the same object i.e aliases  
Immutable objects cannot be changed. The following immutable types are built into Py  
    int  
    float  
    bool (True and False): a subclass of int  
    str (string)  
    tuple  
    frozenset  
    bytes 
Mutable Objects include:  
    list  
    dict  
    set  
    bytearray  
  > The documentation doesn't state that it should be the object's address, just that it must be "guaranteed to be unique and constant for this object during its lifetime." The ID for an object may be different each time you run the program, but while your program's running, the object will have the same id. If Python has to destroy the object and re-create it, then its ID will change.
  
Enumerate function  
- search for index matching search input, and search for part  
- use enumerate function instead - returns pairs of each item with index position  
- can be used with any iterable type
  
Using list comprehensions/generators (ref L96): 
``` python
valid choices = [str(i) for i in range(i, len(available_parts)+1]  
valid choices = []  
# vs  
for i in range (1, len(available_parts)+1):  
	valid_choices.append(str(i))  
	print (valid_choices)  
```
creating a valid choices list using range. i.e auto generation of valid choice based on length of parts list, vs.
``` python
for part in available_parts:  
	print(“{0}:{1}”).format(available_parts .index(parts)+1,part)  
# vs  
for num, part in enumerate (available_parts):  
	print(“{0}:{1}”).format(num+1,part)
```
  
Lists
 - creating lists by combining lists or creating from another sequence e.g. string
- using class initializer list()
- slicing from an existing list
- copy method
# https://stackoverflow.com/questions/2612802/how-do-i-clone-a-list-so-that-it-doesnt-change-unexpectedly-after-assignment/43220129#43220129

- deleting items from a list changes the index of a loop hence it will not iterate and delete properly 
- copying the list may require too much memory
- deleting from sorted data - looping to find the min/max data and deleting based on the found index
e.g. for index in range(len(data)-1,-1,-1) why stop int is -1? to include 0 as an iterable
- for unsorted values, iterate backwards on the conditional, since your loop and reduction in data size run in the same direction
- or use reversed() function to reverse the iterator in the loop function - this allows us to use enumerate and relate the index to the value in reversed order. hence as iterator progreses we are deleting from the back of the list
- append can only be used on a mutable sequence?
# "pass" statement?
# using "is" - check if same object
# https://docs.python.org/3/library/functions.html
# be careful with your variable names as python lets you rebind to even function names


Testing Code with Edge and Corner Cases
We should test our code with data that meets the following criteria:
	Outlying values at both the low and high ends.
	Outlying values at the low end only.
	Outlying values at the high end only.
	No outlying values.
	Only outlying values (no valid ones).
	An empty data set.

Timing code (SRC111)
- each time an element is deleted, the whole list is shuffled down

Nested Lists
- nested loops are used to process nested lists. printing each list of list item by nested loops, for sublist in list -> for item in sublist
- refer to PEP8 style guidef to how to format list of list in code
- .count method can be used to count a sequence
- del function to remove items in a list : del list[index]

- using print function arguments to format how an out put is formatted 
- self parameter (arguments) for methods

- join method to print lists in a loop
- passing the list (sequence) into the join method iterates over the list and coverts the list into a string with the separator it is acting on. can only act on a string type list? must be a homogeneous?
- split method splits a string into a list. it defaults splits on the white space


function signatures
	*objects - you can have none or more objects
	e.g. print: sep = " ", end= "\n"sys.stdout : console
	using "generator" commans

String methods:
	methods vs function: self
	separator.join(input) method - joins all the items in an iterator input with separator. input must all be strings


Tuples
	(mathematical name) ordered set of data (i.e a Python sequence) - note the difference between ordered and sorted. All applicable operations on sequences can be performed on tuples
	tuples are often bracketed in parentheses instead of square brackets, although they are not strictly required. 
		passing tuple literals require double parentheses e.g. print((name, age, "Python", 2020))
	Tuples, unlike lists, are immutable. Trying to change an element in tuple will cause an error i.e. tuple object does not allow assignment. they use less memory as they're immutable.
	You can use indexes to access the individual elements in the tuple e.g. tuple1[2]
	list vs tuples: mutable? tuples are heterogenous.

	Unpacking a tuple:
	a = b = c = d = e = f = 42
	x, y, z = 1, 2, 76
	data = 1, 2, 76 
	x, y, z = data
	Usually tuples should be used for unpacking, as lists that are unpacked often get modified, which may lead to errors if the number of elements are different
	"functions vs class constructor" 
	
Tuples
- ordered set of data that is immutable 
- usually closed in parentheses. e.g. walrus operator?
- indexing within a tuple still use square brackets
- Assigning values respectively to tuple elements. Similar to multiple bindings/assignments
- unpacking tuples are good for referencing variables (i.e. unpacking to variable names) instead of having to access indexes directly
- You can also unpack lists but because lists are mutable if you add elements to the list it will crash (not enough variables to unpack to)
- You can use enumerate to unpack a tuple with the tuples index
- you can unpack the tuple in a lis using a loop: e.g. for A,B,C in list

	
Python doesn't have const or final to make sure values are not change (unlike e.g. C). if something is a constant, you should by convention change everything to capital letters, so you remember. Note that the compiler still does not distinguish that its not modifiable.

You can pass literal value wherever a variable can be used e.g. function argument

you can rebind variables to a name e.g. a function name
	
